---
title: "Trial summary analysis"
author: "Mike"
date: "9/16/2021"
output: html_document
---

```{r setup, echo = FALSE}
library(here)
library(tidyverse)
library(peekbankr)
library(lme4)

# Seed for random number generation
set.seed(42)
knitr::opts_chunk$set(cache.extra = knitr::rand_seed, cache = TRUE)
```


This markdown documents a new way of thinking about modeling variation in LWL data. The idea is to try to:

1. extract a summary statistic for each trial
2. model these summaries with LMMs of various types

The trouble is, what's the right summary statistic? It might be that there's not just one! But let's assume there is one and we just need to sum it up right. 

So we'll start by trying to figure out what the best measure is. We're going to make decisions to maximize within-experiment reliability via ICCs.

We're focused on familiar words here. 


# Get data

```{r, eval=FALSE}
all_aoi_timepoints <- get_aoi_timepoints()
all_stimuli <- get_stimuli()
all_administrations <- get_administrations()
all_subjects <- get_subjects()
all_trial_types <- get_trial_types() 
all_trials <- get_trials() 

aoi_data_joined <- all_aoi_timepoints |>
  right_join(all_administrations) |>
  right_join(all_subjects) |>
  right_join(all_trials) |>
  right_join(all_trial_types) |>
  mutate(stimulus_id = target_id) |>
  right_join(all_stimuli) |>
  select(dataset_name, subject_id, administration_id, trial_id, dataset_id, stimulus_id, t_norm, age, aoi, english_stimulus_label, stimulus_novelty)
# TO DO: looks like a very small number of rows get added in the join, probably a sign of an issue/ ambiguity somewhere.

save(aoi_data_joined, file = here("explorations","data","aoi_data_joined.Rds"))
```

```{r}
load(file = here("explorations","data","aoi_data_joined.Rds"))
```

Take only familiar word data. 
(Note: retaining monolingual+bilingual data; only excluding Tseltal dataset)

```{r}
d_trial <- aoi_data_joined |>
  filter(dataset_name != "casillas_tseltal_2015") |>
  filter(age > 12, age <= 60, 
         stimulus_novelty == "familiar") |> 
  select(dataset_name, subject_id, administration_id, trial_id, 
         dataset_id, stimulus_id, t_norm, age, aoi, english_stimulus_label) |>
  mutate(correct = ifelse(aoi == "target", 1, 
                          ifelse(aoi == "distractor", 0, NA)))
```

# Curve summaries

Now think about what the basic curve is and how to get out various measures. 

```{r}
ggplot(d_trial, aes(x = t_norm, y = correct)) + 
  xlim(-2000,3500)+
  geom_smooth()
```

Seems like we want something that captures 1) the accuracy and 2) the rise coming soon after zero (RT).

(Comment MZ: this summary is a little bit atypical in that the common convention is to summarize average accuracy for each trial first, and then average across items/ within subjects). This is meant e.g. to deal with missing data, e.g. the fact that different trials will have different amounts of (non-missing) looking data. Also note that we are summarizing by administrations, not subjects.)

```{r}
d_summary <- d_trial |>
  group_by(dataset_name, dataset_id, subject_id, administration_id, stimulus_id) |>
  summarise(accuracy = mean(correct[t_norm > 0], na.rm=TRUE),
            prop_data = mean(!is.na(correct[t_norm > 0])))

ggplot(d_summary, aes(x = prop_data, y = accuracy)) +
  geom_point(alpha = .05)
```
There's a lot of missing data and a lot of "zoners" (kids who look only at one side). Zoners are not just missing data kids.

```{r}
ggplot(filter(d_summary, prop_data > .75),
       aes(x = accuracy)) + 
  geom_histogram()
```

# Exclusions

There are two different decisions we could optimize:

1. exclude zoners?
2. exclude based on prop data

Let's try to figure those out. 

We're going to use ICCs, with McGraw & Wong (1996). It seems like we want two-way random effects, no interaction (subjects and items are meaningful). This is type "2A." We want average agreement across units.

One big decision is whether to look across stimulus items, rather than across kids. Across stimulus items returns *much* higher values. This is in part because we typically have more kids than items, and kids are sort of like "raters." 

```{r}
#devtools::install_github("jmgirard/agreement")
library(agreement)

get_icc <- function (x, column = "accuracy", object = "stimulus") {
  if (object == "stimulus") {
    iccs <- dim_icc(x, 
                    model = "2A", 
                    type = "agreement", 
                    unit = "average",
                    object = stimulus_id, 
                    rater = administration_id,
                    score = {{column}}, 
                    bootstrap = 0)
  } else {
    iccs <- dim_icc(x, 
                    model = "2A", 
                    type = "agreement", 
                    unit = "average",
                    object = administration_id, 
                    rater = stimulus_id,
                    score = {{column}}, 
                    bootstrap = 0)
  }
  
  return(iccs$Inter_ICC)
}

iccs <- d_summary |>
  group_by(dataset_name) |> 
  nest() |>
  mutate(icc_acc = unlist(map(data, get_icc))) |>
  select(-data) |>
  unnest(cols = c())

knitr::kable(iccs, digits = 2)
```

Let's look at one dataset. 

```{r}
sa <- d_summary |> 
  filter(dataset_name == "swingley_aslin_2002")

get_icc(sa, object = "stimulus")
get_icc(sa, object = "administration")

# ggplot(sa, aes(x = administration_id, y = accuracy, col = factor(stimulus_id))) +
  # geom_jitter(alpha = .2, width = .5) + 
  # geom_smooth(method = "lm", formula = y ~ 1, se = FALSE)
  
```


Now try to do this programmatically. 

```{r}

icc_sim <- function (zoners_included, exclude_less_than, object) 
{
  df <- d_summary |>
    filter(prop_data > exclude_less_than)
  
  # drop zoners
  if (zoners_included == FALSE) { 
    df <- filter(df, accuracy > 0, accuracy < 1) 
  }
  
  # compute ICCs
  df |> 
    group_by(dataset_name) |> 
    nest() |>
    mutate(icc = unlist(map(data, ~get_icc(., "accuracy", object)))) |>
    select(-data) |>
    unnest(cols = c()) 
}

excl_params <- expand_grid(zoners_included = c(FALSE, TRUE),
                           exclude_less_than = seq(.1, .9, .1), 
                           object = c("stimulus", "administration")) |>
  mutate(icc = pmap(list(zoners_included, exclude_less_than, object), icc_sim)) |>
  unnest(col = icc)
```

```{r}
ggplot(excl_params,
       aes(x = exclude_less_than, y = icc, col = zoners_included)) + 
  geom_jitter(width = .01, alpha = .5) + 
  geom_smooth(method = "lm") + 
  facet_wrap(~object)
```

# What's the measure? 


```{r}
icc_window_sim <- function (t_start = 0, t_end = 4000, object) 
{
  df <- d_trial |>
    filter(t_norm > t_start, t_norm < t_end) |>
    group_by(dataset_name, dataset_id, administration_id, stimulus_id) |>
    summarise(accuracy = mean(correct[t_norm > 0], na.rm=TRUE),
              prop_data = mean(!is.na(correct[t_norm > 0])))
  
  # compute ICCs
  df |> 
    group_by(dataset_name) |> 
    nest() |>
    mutate(icc = unlist(map(data, ~get_icc(., "accuracy", object)))) |>
    select(-data) |>
    unnest(cols = c()) 
}

window_params <- expand_grid(t_start = seq(0,1750,250),
                             t_end = seq(2000,4000,250),
                             object = c("stimulus", "administration")) |>
  mutate(icc = pmap(list(t_start, t_end, object), icc_window_sim)) |>
  unnest(col = icc)

```

```{r}
ggplot(window_params, aes(x = t_start, y = icc, col = as.factor(t_end))) + 
  geom_jitter() + 
  facet_wrap(~object) + 
  geom_smooth(aes(group = as.factor(t_end)), se = FALSE)
```



# Summarising the data

Let's move forward with ALL THE DATA (tm). Window will be something like 500 - 4000  based on the above analysis (which is at best incomplete and at worst...).

```{r}
df <- d_trial |>
    filter(t_norm > 500, t_norm < 4000) |>
    group_by(dataset_name, dataset_id, administration_id, 
             age, stimulus_id, english_stimulus_label) |>
    summarise(accuracy = mean(correct[t_norm > 0], na.rm=TRUE),
              prop_data = mean(!is.na(correct[t_norm > 0]))) 
df <- df[complete.cases(df),]
   
```

Plot all trials by all participants.

```{r}
ggplot(df, aes(x = age/12, y = accuracy)) + 
  geom_point(alpha = .01) + 
  geom_smooth() + 
  geom_hline(lty = 2, yintercept = .5)
```

Try breaking this down by word.

```{r}
hf_words = df |>
  group_by(english_stimulus_label) |> 
  count() |>
  filter(n > 500)

ggplot(filter(df, english_stimulus_label %in% hf_words$english_stimulus_label, 
              age <= 36),
       aes(x = age/12, y = accuracy, col = english_stimulus_label)) + 
  geom_point(alpha = .05) + 
  geom_smooth(se=FALSE) + 
  geom_hline(lty = 2, yintercept = .5)
```

We see lots of wiggliness here. Let's try to use a model to get this out. 

Trying to get in some random effect structure without blowing everything up.

```{r}
df$age_scaled <- scale(df$age)
mod <- lmer(accuracy ~ age_scaled + (1 | administration_id) + 
       (age_scaled | english_stimulus_label) + 
       (1 | dataset_name), 
     data = df)

summary(mod)
```
Let's extract and plot the random effects. 

```{r}
ranefs <- ranef(mod)$english_stimulus_label |>
  tibble() |>
  mutate(english_stimulus_label = rownames(ranef(mod)$english_stimulus_label)) |>
  mutate(english_stimulus_label = fct_reorder(english_stimulus_label, 
                                              `(Intercept)`)) |>
  pivot_longer(cols = -english_stimulus_label, 
               names_to = "coefficient", 
               values_to = "value")
  

ggplot(filter(ranefs, english_stimulus_label %in% hf_words$english_stimulus_label),
       aes(x = english_stimulus_label, y = value)) +
  facet_wrap(~coefficient) + 
  geom_point() + 
  coord_flip()
```
One question we might want to ask is, what's the best measure of word difficulty. I'm not sure! I would have guessed that baby and car would be easy, but not frog or cookie necessarily! I also wouldn't have said that apple would be hard.

If we do the predictions, though, we do see there are some very big study effects for the reflook studies, which have many kids and much older kids. This is tough variance to deal with. 

```{r}
newdata <- expand_grid(age_scaled = seq(min(df$age_scaled), max(df$age_scaled), .1), 
                       english_stimulus_label = hf_words$english_stimulus_label)
newdata$pred <- predict(mod, 
                        newdata = newdata, 
                        re.form = ~  (age_scaled | english_stimulus_label), 
                        type = "response")
newdata$age <- (newdata$age_scaled * sd(df$age)) + mean(df$age)

ggplot(filter(df, english_stimulus_label %in% hf_words$english_stimulus_label),
       aes(x = age/12, y = accuracy, col = english_stimulus_label)) + 
  geom_point(alpha = .1) + 
  geom_line(data = newdata, 
            aes(x = age/12, y = pred, col = english_stimulus_label)) + 
  ggrepel::geom_text_repel(data = filter(newdata, 
                                         age == max(age)), 
                           aes(label = english_stimulus_label, 
                               y = pred)) + 
  geom_hline(lty = 2, yintercept = .5) + 
  xlab("Age (years)") + 
  xlim(1, 6)
```

More generally, we can ask, what are our big goals for this analysis.

1. Look at the "average" word recognition trajectory, item independent and  the functional form of the developmental change. 
2. Predict item-wise variation, e.g. in slope or intercept.

Let's try to sketch each of these. 

# Goal 1: average recognition trajectory

Let's start by noting that there appears to be some functional form to these curves. Descriptively, let's take a look at it word by word. 

## Exponentials

These asymptotic forms might be captured well by an exponential (following Kail 1990): 
$$
y \sim \alpha + \beta e^{-\gamma x}
$$

Where $x$ is age.

```{r}
filter(df, english_stimulus_label %in% hf_words$english_stimulus_label) |>
ggplot(aes(x = age/12, y = accuracy)) + 
  geom_point(alpha = .1) + 
  geom_smooth() + 
  geom_smooth(col = "red", method = "lm", formula = y ~ I((exp(1)**(-x)))) + 
  geom_hline(lty = 2, yintercept = .5) + 
  facet_wrap(~english_stimulus_label)
```

So the exponential model doesn't fit better, at least by AIC.

```{r}
# df$age_scaled <- scale(df$age)
exp_mod <- lmer(accuracy ~ I((exp(1)**(-age_scaled))) + (1 | administration_id) + 
       (I((exp(1)**(-age_scaled))) | english_stimulus_label) + 
       (1 | dataset_name), 
     data = df)

anova(mod,exp_mod)
```

We can still visualize. But it's clear that e.g. "car" is just increasing much more. 

```{r}
newdata$pred <- predict(exp_mod, 
                        newdata = newdata, 
                        re.form = ~ (I((exp(1)**(-age_scaled))) | english_stimulus_label), 
                        type = "response")

ggplot(filter(df, english_stimulus_label %in% hf_words$english_stimulus_label),
       aes(x = age/12, y = accuracy, col = english_stimulus_label)) + 
  geom_point(alpha = .1) + 
  geom_line(data = newdata, 
            aes(x = age/12, y = pred, col = english_stimulus_label)) + 
  ggrepel::geom_text_repel(data = filter(newdata, 
                                         age == max(age)), 
                           aes(label = english_stimulus_label, 
                               y = pred)) + 
  geom_hline(lty = 2, yintercept = .5) + 
  xlab("Age (years)") + 
  xlim(1, 6)
```

## Logits

One more try, let's use a half-logit. That would be:

$$
y \sim .5 + .5\frac{1}{1+e^{\alpha + \beta x}}
$$


```{r}
# df$age_scaled <- scale(df$age)
hl_mod <- lmer(accuracy ~ I(.5 + .5 * (1 / (1 + exp(1)^(age_scaled)))) + (1 | administration_id) + 
       (I(.5 + .5 * (1 / (1 + exp(1)^(age_scaled))))| english_stimulus_label) + 
       (1 | dataset_name), 
     data = df)

summary(hl_mod)
```

```{r}
anova(mod,hl_mod)
```

Somewhat surprisingly, this works and fits better by quite a bit! 

```{r}
newdata$pred <- predict(hl_mod, 
                        newdata = newdata, 
                        re.form = ~ (I(.5 + .5 * (1 / (1 + exp(1)^(age_scaled)))) | english_stimulus_label), 
                        type = "response")

ggplot(filter(df, english_stimulus_label %in% hf_words$english_stimulus_label),
       aes(x = age/12, y = accuracy, col = english_stimulus_label)) + 
  geom_point(alpha = .1) + 
  geom_line(data = newdata, 
            aes(x = age/12, y = pred, col = english_stimulus_label)) + 
  ggrepel::geom_text_repel(data = filter(newdata, 
                                         age == max(age)), 
                           aes(label = english_stimulus_label, 
                               y = pred)) + 
  geom_hline(lty = 2, yintercept = .5) + 
  xlab("Age (years)") + 
  xlim(1, 6)
```
Ok, so this is kind of entertaining, but it's not working perfectly in that the curves are all being shifted by an intercept, rather than the parameters of the logit being shifted... really we want to push the intercept inside the half-logit so that its slope gets moved around. Not sure how to do that right now. 

Onward. 

## Average developmental trajectory

```{r}

newdata$pred <- predict(hl_mod, 
                        newdata = newdata, 
                        re.form = NA, 
                        type = "response")

ggplot(filter(df, english_stimulus_label %in% hf_words$english_stimulus_label),
       aes(x = age/12, y = accuracy, col = english_stimulus_label)) + 
  geom_point(alpha = .1) + 
  geom_line(data = newdata, 
            aes(x = age/12, y = pred), col = "black", size = 1) + 
  ggrepel::geom_text_repel(data = filter(newdata, 
                                         age == max(age)), 
                           aes(label = english_stimulus_label, 
                               y = pred)) + 
  geom_hline(lty = 2, yintercept = .5) + 
  scale_color_discrete(guide = "none") + 
  xlab("Age (years)") + 
  xlim(1, 6)
```

Doesn't look half bad.

# Goal 2: Compare to Wordbank AoAs

Unfinished.
